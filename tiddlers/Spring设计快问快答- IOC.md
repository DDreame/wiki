
Q: DI 是什么?  
A: 依赖注入.指的是当程序需要某些实例对象时动态的对其进行注入.而不是通过 `new object()` 的方式来完成.  

Q: IOC 是什么?与 DI 的区别?   
A: 控制反转,其实也是依赖注入.指将实例对象交给 Spring 来负责, 对象的实例化、销毁等处理均由 Spring 负责.  

Q: Spring 如何控制、管理实例?   
A: 在程序启动时候通过配置文件, 例如 XML 配置、YAML 配置等内容得到需要管理的对象所在的目录, 然后通过扫描类文件和反射来进行实例化.实例化后,按照一定的比如 `<beanName、BeanObject>` 的方式进行存储.当其他对象需要的时候, 根据对象的类型、 `beanName`、注解参数等 获取并返回对应的实例.  

Q: 当多个对象出现循环依赖时候如何解决?   
A: 在不处理切面注入(AOP)的情况下,只需要2级缓存就可以解决,第一级缓存负责存储刚刚实例化完成的 BeanObject, 第二级缓存可以将第一级缓存的 BeanObject 注入到需要的对象中,从而解决依赖注入问题.但是,在最新版的 Spring 中推荐使用构造器注入的方式来解决循环依赖.准确的说,构造器注入使得循环依赖无法使用二级缓存的方式解决,但是会抛出循环依赖错误,指出循环依赖的节点所在.这样可以引导类进行修改,  降低类之间的耦合程度,避免单一类功能职责众多且复杂.

Q: 讲讲 AOP?  
A: 切面编程,主要涉及一些基础代码比如 Log, 数据统计, 数据前后处理等环境下,代码高度可复用,因此使用代理的方式在方法调用的前后,执行相关方法来实现这些功能.   

Q: AOP和3级缓存有什么关系?  
A: 首先是实现 AOP 需要在获取对应类后创建代理类，然后在调用类方法的前后分别调用对应的切面方法。而切面方法本身也是需要一个类来编写的。因此使用2级缓存的话，在第一次创建毛坯实例(没有注入参数的实例)后, 切面方法相关的类也刚刚初始化完成.第二级缓存在注入参数时候也无法分辨一级缓存对应的实例是否是代理实例. 当引入三级缓存后,可以在第一级先完成代理类实例化,第二级缓存负责创建毛坯类,同时使用代理类实例来实现代理类.第三级缓存来完成参数注入.